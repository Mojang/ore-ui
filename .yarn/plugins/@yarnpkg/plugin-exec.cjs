/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-exec",
factory: function (require) {
var plugin=(()=>{var q=Object.create,g=Object.defineProperty,V=Object.defineProperties,_=Object.getOwnPropertyDescriptor,G=Object.getOwnPropertyDescriptors,z=Object.getOwnPropertyNames,M=Object.getOwnPropertySymbols,J=Object.getPrototypeOf,j=Object.prototype.hasOwnProperty,Y=Object.prototype.propertyIsEnumerable;var S=(r,e,t)=>e in r?g(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t,d=(r,e)=>{for(var t in e||(e={}))j.call(e,t)&&S(r,t,e[t]);if(M)for(var t of M(e))Y.call(e,t)&&S(r,t,e[t]);return r},U=(r,e)=>V(r,G(e)),B=r=>g(r,"__esModule",{value:!0});var C=(r,e)=>{for(var t in e)g(r,t,{get:e[t],enumerable:!0})},K=(r,e,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of z(e))!j.call(r,o)&&o!=="default"&&g(r,o,{get:()=>e[o],enumerable:!(t=_(e,o))||t.enumerable});return r},h=r=>K(B(g(r!=null?q(J(r)):{},"default",r&&r.__esModule&&"default"in r?{get:()=>r.default,enumerable:!0}:{value:r,enumerable:!0})),r);var X={};C(X,{default:()=>ee,execUtils:()=>y});var l=h(require("@yarnpkg/core")),n=h(require("@yarnpkg/fslib"));var p="exec:";var y={};C(y,{loadGeneratorFile:()=>P,makeLocator:()=>x,makeSpec:()=>T,parseSpec:()=>v});var u=h(require("@yarnpkg/core")),c=h(require("@yarnpkg/fslib"));function v(r){let{params:e,selector:t}=u.structUtils.parseRange(r),o=c.npath.toPortablePath(t);return{parentLocator:e&&typeof e.locator=="string"?u.structUtils.parseLocator(e.locator):null,path:o}}function T({parentLocator:r,path:e,generatorHash:t,protocol:o}){let a=r!==null?{locator:u.structUtils.stringifyLocator(r)}:{},s=typeof t!="undefined"?{hash:t}:{};return u.structUtils.makeRange({protocol:o,source:e,selector:e,params:d(d({},s),a)})}function x(r,{parentLocator:e,path:t,generatorHash:o,protocol:a}){return u.structUtils.makeLocator(r,T({parentLocator:e,path:t,generatorHash:o,protocol:a}))}async function P(r,e,t){let{parentLocator:o,path:a}=u.structUtils.parseFileStyleRange(r,{protocol:e}),s=c.ppath.isAbsolute(a)?{packageFs:new c.CwdFS(c.PortablePath.root),prefixPath:c.PortablePath.dot,localPath:c.PortablePath.root}:await t.fetcher.fetch(o,t),i=s.localPath?{packageFs:new c.CwdFS(c.PortablePath.root),prefixPath:c.ppath.relative(c.PortablePath.root,s.localPath)}:s;s!==i&&s.releaseFs&&s.releaseFs();let f=i.packageFs,b=c.ppath.join(i.prefixPath,a);return await f.readFilePromise(b,"utf8")}var O=class{supports(e,t){return!!e.reference.startsWith(p)}getLocalPath(e,t){let{parentLocator:o,path:a}=l.structUtils.parseFileStyleRange(e.reference,{protocol:p});if(n.ppath.isAbsolute(a))return a;let s=t.fetcher.getLocalPath(o,t);return s===null?null:n.ppath.resolve(s,a)}async fetch(e,t){let o=t.checksums.get(e.locatorHash)||null,[a,s,i]=await t.cache.fetchPackageFromCache(e,o,{onHit:()=>t.report.reportCacheHit(e),onMiss:()=>t.report.reportCacheMiss(e),loader:()=>this.fetchFromDisk(e,t),skipIntegrityCheck:t.skipIntegrityCheck});return{packageFs:a,releaseFs:s,prefixPath:l.structUtils.getIdentVendorPath(e),localPath:this.getLocalPath(e,t),checksum:i}}async fetchFromDisk(e,t){let o=await P(e.reference,p,t);return n.xfs.mktempPromise(async a=>{let s=n.ppath.join(a,"generator.js");return await n.xfs.writeFilePromise(s,o),n.xfs.mktempPromise(async i=>{if(await this.generatePackage(i,e,s,t),!n.xfs.existsSync(n.ppath.join(i,"build")))throw new Error("The script should have generated a build directory");return await l.tgzUtils.makeArchiveFromDirectory(n.ppath.join(i,"build"),{prefixPath:l.structUtils.getIdentVendorPath(e),compressionLevel:t.project.configuration.get("compressionLevel")})})})}async generatePackage(e,t,o,a){return await n.xfs.mktempPromise(async s=>{let i=await l.scriptUtils.makeScriptEnv({project:a.project,binFolder:s}),f=n.ppath.join(e,"runtime.js");return await n.xfs.mktempPromise(async b=>{let w=n.ppath.join(b,"buildfile.log"),H=null,F=n.xfs.createWriteStream(w),I=F,E=n.ppath.join(e,"generator"),R=n.ppath.join(e,"build");await n.xfs.mkdirPromise(E),await n.xfs.mkdirPromise(R);let W={tempDir:n.npath.fromPortablePath(E),buildDir:n.npath.fromPortablePath(R),locator:l.structUtils.stringifyLocator(t)};await n.xfs.writeFilePromise(f,`
          // Expose 'Module' as a global variable
          Object.defineProperty(global, 'Module', {
            get: () => require('module'),
            configurable: true,
            enumerable: false,
          });

          // Expose non-hidden built-in modules as global variables
          for (const name of Module.builtinModules.filter((name) => name !== 'module' && !name.startsWith('_'))) {
            Object.defineProperty(global, name, {
              get: () => require(name),
              configurable: true,
              enumerable: false,
            });
          }

          // Expose the 'execEnv' global variable
          Object.defineProperty(global, 'execEnv', {
            value: {
              ...${JSON.stringify(W)},
            },
            enumerable: true,
          });
        `);let k=i.NODE_OPTIONS||"",$=/\s*--require\s+\S*\.pnp\.c?js\s*/g;k=k.replace($," ").trim(),i.NODE_OPTIONS=k,F.write(`# This file contains the result of Yarn generating a package (${l.structUtils.stringifyLocator(t)})
`),F.write(`
`);let{code:D}=await l.execUtils.pipevp(process.execPath,["--require",n.npath.fromPortablePath(f),n.npath.fromPortablePath(o),l.structUtils.stringifyIdent(t)],{cwd:e,env:i,stdin:H,stdout:F,stderr:I});if(D!==0)throw n.xfs.detachTemp(b),new Error(`Package generation failed (exit code ${D}, logs can be found here: ${w})`)})})}};var N=h(require("@yarnpkg/core")),A=h(require("@yarnpkg/core")),m=h(require("@yarnpkg/core"));var Q=1,L=class{supportsDescriptor(e,t){return!!e.range.startsWith(p)}supportsLocator(e,t){return!!e.reference.startsWith(p)}shouldPersistResolution(e,t){return!1}bindDescriptor(e,t,o){return m.structUtils.bindDescriptor(e,{locator:m.structUtils.stringifyLocator(t)})}getResolutionDependencies(e,t){return[]}async getCandidates(e,t,o){if(!o.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");let{path:a,parentLocator:s}=v(e.range);if(s===null)throw new Error("Assertion failed: The descriptor should have been bound");let i=await P(m.structUtils.makeRange({protocol:p,source:a,selector:a,params:{locator:m.structUtils.stringifyLocator(s)}}),p,o.fetchOptions),f=m.hashUtils.makeHash(`${Q}`,i).slice(0,6);return[x(e,{parentLocator:s,path:a,generatorHash:f,protocol:p})]}async getSatisfying(e,t,o){return null}async resolve(e,t){if(!t.fetchOptions)throw new Error("Assertion failed: This resolver cannot be used unless a fetcher is configured");let o=await t.fetchOptions.fetcher.fetch(e,t.fetchOptions),a=await m.miscUtils.releaseAfterUseAsync(async()=>await N.Manifest.find(o.prefixPath,{baseFs:o.packageFs}),o.releaseFs);return U(d({},e),{version:a.version||"0.0.0",languageName:a.languageName||t.project.configuration.get("defaultLanguageName"),linkType:A.LinkType.HARD,dependencies:a.dependencies,peerDependencies:a.peerDependencies,dependenciesMeta:a.dependenciesMeta,peerDependenciesMeta:a.peerDependenciesMeta,bin:a.bin})}};var Z={fetchers:[O],resolvers:[L]},ee=Z;return X;})();
return plugin;
}
};
